# AI 全栈项目

## 技能点

### react 开发全家桶

- react + typescript(JS超级)
- react-router-dom(前端路由)
- zustand (中央状态管理)
- axios (http请求库)

### 后端

- node + ts
- nestjs 企业级别后端开发框架
- psql 数据库
- redis 缓存数据库

### AI

- langchain
- coze/n8n
- llm
- trae/cursor

## 项目安排

- frontend
- backend
- ai_server
- admin 后台管理系统

## git 操作

- 全新的实战项目
  git init
- 提交的时机
  每次完成一个相对独立的模块后，提交一下
  提交信息要准确完整

## react 全家桶

### react-router-dom

- 前端路由
  早期前端没有路由，路由由后端，前端是切图崽
  前后端分离， 前端有独立的（html5）路由，实现页面切换。
- 两种形式
  - HashRouter #/ 丑一点 很温柔 兼容性很好 瞄点
  - BrowserRouter / 和后端路由一样，需要使用到html5 history API
    兼容不好，ie11 之前不兼容， 现在的浏览器几乎都支持
- as Router 可读性
- 性能， 快 页面组件的懒加载
  / Home 延迟一下About 阻止加载
  /About About

### 路由有多少种？

- 普通路由
- 动态路由 /product/:id
- 通配路由 \*
- 嵌套路由 Outlet
  <Outlet> 是 React Router DOM 中的组件，用于在父路由元素中渲染其子路由匹配到的内容。
- 鉴权路由（路由守卫） ProtectRoute
- redirect 重定向路由 Navigate

### 路由生成访问历史

history 栈 先进后出
replace redirect 跳转，会替换当前的历史记录

### 单页应用

- 传统的开发是多页的，基于http 请求，每次url 发生改变后，去服务器重新请求整个页面。
  体验不好，页面会白一下
- 单页应用 react-router-dom html5 history
  前端路由
  路由改变后
  前端会收到一个事件， 讲匹配的新路由显示在页面上

## typescript

JavaScript 超级 ， 强类型静态语言

- 安装 ts
  npm install -g typescript
- ts 的优点
  - 静态类型
  - 边写边检查bug
  - 编译时检查类型错误
  - 代码建议、文档查看都非常方便
  - 没有使用变量等垃圾代码提示未使用（console.log（））
    重构、修改别人的代码
    干净的代码

### typescript 实战 todos

### zustand 状态管理

如果说国家需要有中央银行，那么前端项目就需要中央状态管理系统。zustand \redux

- 组件 = UI+State
- store 将状态存到store仓库中管理
  全局共享
- 基于hooks思想实现的

## 数据库设计

- 关系型数据库 mysql\postgresql
  是一种以二维表格（行/列）组织存储数据，通过主键（Primary key）
  外键简历表格间逻辑关联，遵循ACID 事务特性保证数据一致性和可靠性的数据库。
  表Table users 类
  row 实例
  column 属性

### 主键

- 词典
  索引目录
- 唯一的 ， 自增的
- 高效 利用索引

### 唯一索引 uniq 约束

- username 唯一性， 正确性

### 外键 约束 foreign key

- posts 文章id, userId
- id 引用 users 表的主键
  posts.userId == user.id 关联

### 普通外键 key

- 不能乱建
- 查询的频繁度

### 文章系统

- 文章表 posts
- 用户表 users
- 评论表 comments
- 点赞表 likes
- 标签表 tags
- 收藏表 favorites

### 连接

- 左连接 left join
  左表所有数据都显示，右表匹配的显示，不匹配的null
- 右连接 right join
  右表所有数据都显示，左表匹配的显示，不匹配的null
- 内连接 inner join
  只显示左右表匹配的数据

### ACID

- 事务 transaction
  数据库操作的最小单位，
  A Atomicity 原子性
  要么都成功， 要么全部失败回滚。
  转账 扣A的100元，和增加B的100元。 转账事务
- A 成功 type out 减少总金额 先 成功。回滚失败
- B 成功 type in 增加总金额 后 失败， 回滚A的操作

C Consistency 一致性
数据库从一个一致状态转换到另一个一致状态，
转账事务中，A和B的总金额保持不变。

Isolation 隔离性
并发执行的事务 相互独立， 互不干扰。
两笔转账， A转B 100元， C 转B 200 元

D Durability 持久性
事务一旦提交， 对数据库的改变是永久的， 不会因为系统故障而丢失。

### psql

#### 基本操作

- \list 列出所有数据库
- 创建数据库
  CREATE DATABASE xuebi WITH OWNER=postgres ENCODING='UTF-8';
- 进入数据库
  \c xuebi

### prompt 建表

```
你是一位psql高级工程师，需要设计一个users表,
包含id, name, password三个字段。id 自增，主键，name 不能重复，
请给出建表sql

CREATE TABLE users (
    -- 使用 BIGINT 避免未来数据量过大导致 ID 溢出，IDENTITY 是 SQL 标准自增方式
    -- INT（上限21亿) BIGINT（8字节）
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    -- UNIQUE 约束会自动创建索引，NOT NULL 保证数据完整性
    name VARCHAR(255) NOT NULL UNIQUE,

    -- 密码字段，通常长度设为 255 以适配各种哈希加密算法（如 bcrypt）
    password VARCHAR(255) NOT NULL,

    -- 高级工程师通常会增加这两个审计字段
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
```

### seeds 初始化数据

```
  INSERT INTO "users" ("id", "name", "password") VALUES
  ('1', '王皓', '$2b$10$CsO/ykedPpuxqUETBZTYm.F2U4TXDdo01rLmoRPwjKBv3pIL5pnWq'),
  ('2', '小雪', '$2b$10$CsO/ykedPpuxqUETBZTYm.F2U4TXDdo01rLmoRPwjKBv3pIL5pnWq'),
  ('3', '李白', '$2b$10$CsO/ykedPpuxqUETBZTYm.F2U4TXDdo01rLmoRPwjKBv3pIL5pnWq'),
  ('4', '杜甫', '$2b$10$CsO/ykedPpuxqUETBZTYm.F2U4TXDdo01rLmoRPwjKBv3pIL5pnWq'),
  ('5', '白居易', '$2b$10$CsO/ykedPpuxqUETBZTYm.F2U4TXDdo01rLmoRPwjKBv3pIL5pnWq'),
  ('6', '张三', '$2b$10$CsO/ykedPpuxqUETBZTYm.F2U4TXDdo01rLmoRPwjKBv3pIL5pnWq');
```

你是一位psql 高级工程师， 需要建一个posts 表， 包含id, title, content,userId 三个字段。id 自增， 主键， title 不为空，不超过255个字符， content 长文本， usersId 是bigint 类型，是 users 表的外键，请给出建表sql

CREATE TABLE posts (
id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
title VARCHAR(255) NOT NULL,
content TEXT,
"userId" BigInt NOT NULL,
-- 高级工程师通常会增加这两个审计字段
created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT fk_posts_user FOREIGN KEY ("userId") REFERENCES users(id) ON DELETE CASCADE

);

## nestjs

### express 及简框架

nestjs 企业级开发，基于typescript ,采用模块化架构和依赖注入，
旨在构建高效、可扩展切易于维护的企业级后端应用

- npm i -g @nestjs/cli
- 新建项目 nest new nest-test-demo

### nestjs 理解

- 工厂模式
- main.ts 入口文件
- Module
  app.module.ts

### http 请求动作

语义化 restful 一切皆资源  
Method + url 定义方式

- GET/POST
- PUT 上传（更新）头像
- PATCH 局部更新 nickname password。。。
- DELETE 删除用户

## notes AI 全栈项目

- 登录功能
- 文章系统
- AIGC 功能
- nestjs 后端

### shadcn

- 页面由组件构成，选用第三方组件库
- 严格按需加载
- 组件下载到本地，可以随意的修改。
- 基于tailwindcss
- 配置alias 设置路径别名，更短，好用

### vite 的配置

- vite.config.ts 配置对象
- plugins 插件
  react | vue
  tailwindcss
- resolve
  alias 路径别名
  @ -> \_\_dirname/src 默认使用 @ 指向 src
  npm i -D @types/node node 来到ts 开发的时候
  单独安装了node 的类型申明文件
- ts 配置文件
  根目录下的 tsconfig.app.json
  compilerOptions 目录输出建议
  baseUrl
  path

- npx shadcn@latest init
  npx 是 Node.js 自带的工具，用于临时安装并**执行** npm 包中的命令，无需全局或本地预先安装。
  不用预先安装 ， 试用，测试那边， 用完会删除
- shadcn 提供命令行
  - button
    npx shadcn@latest add button

### 路由

- 路由懒加载（性能优化的关键）
- suspense + lazy 实现路由懒加载
- 自定义loading 组件

### keepalive

### 登录store的持久化

### BackToTop组件

- 通用组件
- 自有状态isVisible
- onScroll 判断一个阀值
- scroll事件频繁触发，性能优化
  节流 utils 目录下 工具函数
- 组件卸载时 移除事件监听，防止内存泄漏。

### 幻灯片组件 slides

- shadcn 提供了 Carousel、CarouselContent、CarouselItem、
  一组组件，层次结构
- 自动播放的功能作为插件引入， shadcn 简单性能好，定制性更好
  useRef 持久化可变的对象
  plugins=[]
- api 向外暴露Carsoul 的各种功能
  selectedIndex 私有状态
  api onSelect 方法 改变之
- 指示点
  循环输出
  动态类名
- css
  - transition-all
  - gradient 线性渐变， 取代图片（渐变色）做背景
    性能优化 图片做背景 http下载的开销，减少http并发数

### store

- user 全局共享
- 每个页面级别组件都有自己独立的store
  组件 UI 和 数据分离

### Post List

- 数据怎么提供呢？
  - 真实数据 在后端
  - axios 请求 后端api
  - 前端要等待后端接口吗？不能等，前后端分离的基础上，
    前端可以自行解决数据需求？ mock 一下 伪造请求
    api接口文档
    GET /api/posts?page=1&limit=10 返回内容
    {
    status: 200,
    list: Post[]
    }
    只要切换后端真正的地址，无缝对接

### mockjs

- 前端接口伪造，开发时候用，上线前切换成后端接口，
  vite 启动 mock
- 前后端确立接口开发文档

### posts mock

- 阅读接口文档
- mockjs 语法
  mockPath posts.js
  export default {
  {
  url:,
  method:,
  response:(req, res) => {}
  }
  }
  - mockjs 随机功能 @
  - 分页机制
    - page, limit parseInt
    - start, end, total, totalPage
    - slice
    - pagination

## JWT登录

- http 无状态的
  Cookie Authorization token 身份令牌
- 颁发令牌 token
- jwt
  pnpm i json(用户身份对象)web(形式)token(令牌)
  用户名+密码 {id:1, name:'admin'} json 加密成一个token
  请求时，再传过来 服务器端 decode 得到用户对象，
  - sign方法 服务器 用户对象， secret, 过期时间 给前端颁发token
  - decode方法，解析请求头 authorization 服务器拿到用户对象

## api 后端接口项目

- nest new posts
  高度模块化、依赖注入特性的企业级开发框架
- 数据库

### prisma ORM

将数据库映射成对象
Table -> 类
row -> 实例
props -> props
psql/mysql sql 太专业了，prisma 翻译官
后端 -》 prisma -> sql
User(service class) === User(table)
create === Insert
findMany === Select

### ORM ObjectRelationMapping 对象关系映射

### Prisma 的初始化流程

- 建数据库
- prisma 命令行 + @prisma/client(ORM)
- npx prisma init 初始化prisma项目，创建prisma 文件夹，schema 文件(数据表的设计蓝图)，并生成了.env 文件（数据库连接的url）
- npx prisma studio 打开 prisma 可视化界面

### schema 文件

数据库是最重要的 ，schema 就是数据库设计稿， 设计文件保留下来
用model模型类(数据库中的表是代码里的类)的概念 描述数据表
@用来定义模型字段的行为、约束和数据库映射规则的关键字
@id primary key
@default(@increment()) 自增主键
@db.Varchar(255)
@unique

### migrate 数据表的迁移

- 方便
- 留下日志
- npx prisma migrate dev --name init_user

### seeds

### DTO Data Transfer Object 数据传输对象

丛前端-》后端-》控制器-》service transfer 过程

- dto/post-query.dto.ts -> post 查询参数
- dto/post-new.dto.ts -> post 新增参数
- 功能模块化 高内聚，低耦合
- class-validator 验证器
  将参数的校验 流程化， 规范化
- 全局配置一下

### pipe 管道

- _数据验证_
  这是最常用的功能。管道会检查客户端传入的数据是否符合规则。
  拦截非法数据：如果数据类型错误（如要数字却传了字符串）或格式不对（如邮箱格式错误），管道会直接拦截请求，返回 400 Bad Request 错误，阻止非法数据进入你的业务逻辑。
  自动报错：省去了你在控制器里写大量 if-else 判断的麻烦。
- _数据转换_
  HTTP 请求传来的数据通常是字符串形式。
  类型转换：管道可以自动将请求参数（如 id）从字符串转换成数字或布尔值，确保进入业务逻辑的数据类型是正确的。

### @prisma/client

- 怎么给service提供 client 代替db
- 文章列表
  - 背后有多条sql
    count posts 用于分页 total
  - 文章列表详情
    title content --------
    - 拿到每篇文章的id tags
    - likes
- dto
  - 用户提交（query?, body）打理的标准
  - main.ts 启用中间件
    约传多传的不要
    少传的报错
    transform 转换类型
    class-validator 属性类型约束的装饰类
    class-transformer 类型转换
    约束 query | body

### prisma 流程

- prisma 命令行、@prisma/client 两个@6
- npx prisma init
  prisma 文件夹 schema 文件
  .env 描述psql 连接的字符串
- schema 编写 Model（属性，类型， key, 关系）
- npx prisma dev migrate --init_user
- npx prisma generate 生成client 需要的内容
- prisma module
  - 和nest 融合了
  - prisma module provider prisma service
    @Global

### 线上课

72 行大写的Tag 变小写
第二段post createdAt/updatedAt

## 图片懒加载

- img的src http 请求 并发 加载慢
  - 需要加载的图片 首页首屏
    图片用占位图片（小），优先去加载html,css, 首屏的显示速度优先。
  - 视图窗口（viewport）之外的 不需要加载
    鼠标滚动的时候 onscroll 事件 要加载 节流 滚动哪里懒加载进入视窗的图片
  - 首先实例化IntersectionObserver
    Observer 观察者（设计模式）模式
    Intersection 与viewport 的交叉
    entries 所有被观察的元素
    isIntersecting 是否出现
    dataset-src 交给 图片的src
    observer.unobserve 取消观察
    给所有的.lazy 加观察 observer.observe()

### 静态服务器

- service, 提供数据，动态
- 静态资源 html/css/js/img
- 静态服务器是专门用于存储和提供静态文件的服务器。它的核心功能是将预先准备好的文件（如 HTML、CSS、JavaScript、图片、视频等）原封不动地传输给客户端，不进行任何加工或计算。
- 根目录下的uploads/
- main.ts 启用静态资源服务器
  区别于动态资源，不需要controller 提供路由
  只需要去配置一下
- app.useStaticAssets 启用静态资源服务器
- path join  
  process.cwd() uploads 拼起来  
  cwd Current Working Directory 当前工作目录
  localhost:3000/uploads/avatar/3c203530f8f11f4673f9060a85a51b37.jpg

### 接口数据格式调整

- 依据前后端文档格式要求
- prisma-client 查处数据之后， 通过map 格式化输出
- 后端对接口文档的尊重

### 图片懒加载

- 列表一定要做图片的懒加载
- react-lazy-load 提供了 组件 ， 背后 IntersectionObserver
- 包着原来要显示的图片 loading="lazy"

### InfiniteScroll 组件

- 通用组件
  为列表带来分页无限加载能力
- 抽象封装能力
  可定制的列表作为children
  在children 下面添加一个哨兵节点
- 使用IntersectionObserver threshold 0.0
- loadMore loading hasMore store
- 联动启动

### 首页优化

- 反复切换 首页，其他页面 重复加载
- 路由的切换
  - SPA
    单页应用 SPA Single Page Application
    React + React-Router
    快 不需要白屏 等待
  - MPA
    / /detail/:id /login
    完全卸载旧页面，加载新页面
    没有前端路由 请求服务器 后端路由 http请求 完整的html
    前端负责路由， js 中拿出来组件（前端），进行替换
- 首页太重要了， 用户频繁的在首页和其他页面切换（美团，天猫）
  首页的不断卸载挂载， 重复渲染 不违和了

### KeepAlive

- 首页使用频率大，当去别的页面的时候， 隐藏首页，不要卸载
- home 不能卸载， keep alive
- react-activation
  cache 缓存 home , 界面和数据都保持
  display:none 离开文档流
  KeepAlive + ALiveScope
  pnpm i react-activation

### 登录功能

- 注册
  - password 单向加密
    不能解密， 防程序员，黑客， 可以确保密码安全
    bcrypt 单向哈希
    系统把我的密码算一个hash 值， 存储在数据库中，黑客无法解密密码，他拿到hash 值也无法反向推导出密码。
    - SELECT setval('users_id_seq', (SELECT COALESCE(MAX(id), 0) FROM users));
      修复或重置 users 表的自增主键序列，使其与表中现有数据的最大 ID 同步。
- 登录
  cookie 之前的登录解决方案， 小饼干 http 自动带上cookie ,
  cookie比localStorage 更小的本地存储， 存身份信息
  JWT Authorization 字段 axios 请求拦截
  轻量级，跨域 JSON（用户对象信息 不安全） Web Token(hash 令牌)
  双向（加解密sigh/decode secret）
  身份验证
- Auth 鉴权模块
  - @nestjs/jwt 需要安装的，但是是nestjs 本身提供的jwt 身份验证模块
    jwt 协议
  - JWTService sign
  - JWTModule Auth模块里面import 它，方便注入依赖

### JWT 双token 机制

- mockjs, 使用了jsonwebtoken 单token sign/decoded
- 单token 容易被中间人截获，不安全。双token机制
- access_token(短， 分钟为单位) 和refresh_token（长， 天为单位）
  一样的具有token 验证的能力（JWTService.signAsync）
  axios 请求拦截中 access_token , 会比较快的过期
  会拿出refresh_token 后端可以识别用户身份 再次生成一对token
- 新的token 对覆盖旧的， 继续使用access_token就可以了。
- refresh_token 7天， 需要重新登录
- Promise.all 面试官问
  举个例子 nest.js posts 列表查询， count, 和 list Promise.all 并发查询。
  还有nest.js 双token 的并发生成 token 生成是需要开销性能和时间

- 当 Access Token 过期了，用户此时发起请求，服务器会返回 401 Unauthorized 错误。
  这时候，前端的拦截器（如 Axios 的响应拦截器）会捕捉到这个 401 错误，并触发“救援机制”：
  暂停：暂停刚才那个失败的请求（比如发帖请求）。
  出动：携带 Refresh Token，向专门的刷新接口（如 /auth/refresh）发起请求。
  验证：服务器收到 Refresh Token，验证其是否合法、是否过期。
  续命：
  如果验证通过，服务器生成全新的 Access Token（有时连 Refresh Token 也一起更新）。
  前端拿到新的 Access Token，替换掉旧的。
  重试：拿出刚才暂存的“发帖请求”，用新的 Access Token 重新发送。
  完成：用户甚至不知道刚才发生了“续命”操作，文章成功发布。

### 错误异常模块

- 后端，错误处理是核心模块。
  - 3xx (重定向)：资源已移动到新位置，需要客户端重定向。
    301：资源已永久移动到新位置。搜索引擎会更新链接，浏览器会缓存重定向。
  - 4xx (客户端错误)：通常是调用方的问题，不需要重试。
    400 Bad Request：参数格式不对（比如邮箱格式错了）。
    401 Unauthorized：没登录/没带 Token。 没有权限访问。
    403 Forbidden：登录了，但没有权限访问资源（比如普通用户想删管理员文章）。
    404 Not Found：资源不存在。
  - 5xx (服务端错误)：通常是代码出 bug 或服务器挂了，需要排查。
    500 Internal Server Error：代码炸了（比如空指针异常）。
- try {} catch() { .... }
  catch 错误可以被善待
- BadRequestException
  nestjs 准备了各种异常
  各种异常处理类，解决各总问题
  - return
  - 400|401|403|500.... statusCode , message

## 鉴权处理

- 新增文章 点赞等 需要权限的操作， 需要先登录。
- access_token, refresh_token
  api 请求由axios 自动带上access_token , Authorization
- backend posts.controller createPost 方法
  createPost 需要收到鉴权的保护？ nestjs 提供了 guard 的概念  
  req Authorization access_token ?
  拿到 user ? @nestjs/jwt verify?

### nestjs useGard

UseGards 是一个装饰器，用于在控制器或路由处理方法上应用守卫（Guard）
会在路由处理方法前，先执行Guard函数，鉴权
如果鉴权失败，401， 直接退出
如果成功 用jwt verify 出来的对象帮我们添加到req 对象上
路由处理方法里面就可以使用user 信息

- AuthGuard('jwt') 由@nestjs/passport 直接提供
- Unknown authentication strategy "jwt"
  jwt 鉴权策略在那？
  会去查找
- jwt 双token 流程
  - 双token 生成， @nestjs/jwt
  - 鉴权 @nests/guard useGuard
  - 刷新 ？ refresh  
    post /posts 新增 token
    useGuard 返回 401 ?

### refresh token

- axios 响应拦截，有成功处理函数， 如果服务器端抛出异常， 执行失败处理函数。
  找到了refresh 入口

- 为什么浏览器直接访问注册接口会失败？
  - 注册接口是 POST 请求
  - 浏览器直接访问 URL 时发送的是 GET 请求
  - 后端只处理 POST 请求，所以会返回 404 错误

### chatbot

- 流式输出
- llm 提的问题 input
  llm 函数(参数1...) 百亿
  llm 返回 output
  智能
  token 生成按token 来生成
  token生成token 神经网络系统 AIGC tokens 的循环生成
  流式？

- 前端用户体验
  响应更快，打字机一样效果，像水流逐字输出。

- http 请求
  Connection: Keep Alive
  事件监听 SSE Server Send Event
  onToken('[DONE]')

### chatbot hook

- 将bot 的响应式业务剥离
- vercel ai-sdk/react
  Ai 前端应用， nextjs(react ssr框架)
  @ai sdk 封装了chatbot , 快速开发
  - chatbot UI 、响应式和AI 业务剥离
    pnpm i @ai-sdk/react@1.2.12
- mockjs 流式输出
  rawResponse 支持流式输出（面试时候不用说）
  - model streaming: true 边生成变响应
  - 前端 事件监听 SSE Server Send Event 流式响应 @ai/sdk 封装了
  - 响应头设置
    Content-Type: text/event-stream
    Cache-Control: no-cache
    Connection: keep-alive
  - reader.read() 读取响应体
  - TextDecoder 解码响应体
  - res.write 写入响应体
  - data:[end] res.end()
  - langchain 后端的业务封装
    this.chatModel.steam()
    for await (const chunk of stream) {

    }

## 搜索功能

- mockjs 搜索接口
  GET
  /api/search?keyword=编码
  中文这种非ASCII 字符 需要编码 encodeURI
  - 字符串匹配
  - like模糊匹配
  - 基于大模型的语义搜索
    前端
    vue ? react
    hello == 你好
- 服务器开销比较大
- 封装了 useDebounce 防抖 hooks
  - 响应式的 debounce 值
  - useEffect 清除函数 防抖功能
  - 专一功能

### 语义搜索 embedding

hello 你好 文本匹配失效，语义相似度
数学问题，向量的概念 高纬世界 openai 1536

- openai embedding.create() 接口
- fs/promises 文件模块
  - readFile
    JSON.parse
  - writeFile
    JSON.stringify()
- 向量的相似度计算

### RAG

Retrieve(检索) Augument（增强） Generation(生成)

1. llm 可以去检索一些文档（私有知识库 embedding）
2. 将检索到的内容(相似度)， 作为上下文 ，增强prompt
3. 交给大模型生成

- rag 界面，类似chatbot ,上传文件

### Git AI 工具

- 提效
  AI editor
- 专业
  新手和专家一样工作
  git commit -m '' 用和本轮开发相关，能够表达功能的描述
  css BEM 国际命名规范
  大厂规范，Conventional（约定） Commits
  Conventional Commits 是一种写 commit 信息的规范，简单说就是让每次 Git 提交的消息格式统一，比如用 feat、fix、docs 这些前缀开头，后面跟上具体干了啥。这样不仅能让人一眼看懂改了什么，还能自动生成 changelog、自动打版本号，对团队协作和发布特别有帮助。
  有描述性
  功能性
  可读性
- 使用流程 规范化的操作
  - git diff 拿到结果
  - prompt commit
  - git commit -m ''

# js 语言工作的底层机制
  - v8引擎
  - 调用栈
    - 编译阶段，创建执行上下文
    - 执行阶段
  - 执行上下文（底部全局，函数，块级）
  - 作用域
    - 全局作用域
    - 函数作用域
    - 块级作用域
    变量的查找范围和生命周期
    - 块级作用域  要维持栈结构的词法环境
    - hoisting  变量提升  变量在声明之前就可以使用，但是只能使用默认值  简单高效
## 作用域链
- 不知道作用域链查找的规则
  - 一定要知道查找规则
  - 作用域链 变量的的查找路径
    - 从当前执行上下文的变量环境开始查找
    - 如果没有找到，就去上一级执行上下文的变量环境查找
    - 直到全局执行上下文的变量环境
    按函数声明的时候（编译），已经决定了作用域链的查找路径   词法作用域
- 为什么是全局的作用域
  - 为什么不是foo()? 极客邦
  函数在**调用栈**中的顺序

## 词法作用域 以及(词法)作用域链（静态作用域）
  指作用域是由代码中函数声明的位置决定的，而不是由函数调用的位置决定的。
  词法作用域是静态的作用域
  作用域链也叫词法作用域链，静态的，只和函数声明的位置相关
  在编译阶段就决定好了，和调用没有关系
  
  词法环境是为了实现块级作用域
  词法作用域是在编译阶段就确定的，而不是在运行时确定的。
  词法作用域链是由多个词法环境组成的链表，每个词法环境都包含了对外部环境的引用。

## 闭包 closure
  无处不在的高级概念
  静态的，词法作用域后
- 函数运行的时候，也有一种情况
  就好像函数运行的时候不是在它声明的位置时，作用域

- 闭包基于词法作用域链的理解
- 形成条件是函数嵌套函数
- 被闭包的函数要在外部可以访问到 return
- 被闭包的函数执行的时候能找到定义他的时候的执行上下文中的变量

foo函数执行完后，栖止行上下文从栈顶弹出了，但是由于返回的getName 使用了foo函数内部的变量myName和test1,这两个变量依然在内存中，有点像getName,setName方法背的一个专属背包
这个背包，就像闭包，把函数内部的变量和方法，都保存在了这个背包中，直到getName方法执行完后，这个背包才会被销毁。
这个闭包里面的变量叫做自由变量





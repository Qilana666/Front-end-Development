# js 内存机制

- js执行机制
  - 调用栈
  - 执行上下文
    - 变量环境
    - 词法环境
    - outer 词法作用域链
      - 闭包 closure
    - this

- JS 内存
  - 栈内存 简单数据类型 
  - 堆内存 复杂数据类型 
    - 为什么是这两个？

- js是什么语言？ 动态弱类型语言
  - ❌️静态语言 
    使用之前需要确认变量数据类型的语言
  - ✅️动态语言
    运行过程中需要检查数据类型的语言
  - ✅️弱类型语言
    各种类型都可以转换
  - ❌️强类型语言
    不可以设置其它类型

- js 要直接操作内存吗？
  不需要
  c,c++ malloc free 操作内存
  js 不用直接操作内存

- Object 类型
  key:value 键值对 key string|symbol value 任意类型
- 八种数据类型
  - 简单数据类型和复杂数据类型
  两种机制就搞定了

## 内存空间
- 代码空间
  存储js代码
  代码从硬盘读取到内存中
- 栈内存
  存储简单数据类型 但不止简单数据类型 还有函数调用栈 （执行上下文） 
  执行栈也叫调用栈 （js执行的主角） 
  快，好管理，大小固定
  调用栈的栈顶切换要快 小 连续 切换很频繁
- 堆内存
  存储复杂数据类型
  打辅助
  大对象的空间，分配更耗时
  对象动态的，不连续的

  javascript v8引擎 需要用栈来维护程序执行期间上下文的状态
  如果栈空间太大了，不连续的（复杂数据类型也放在栈中，会影响上下文切换的效率）
  进而影响整个程序的执行效率
  执行上下文的切换其实是执行栈栈顶指针的偏移
  栈空间，用来存放原始数据类型，空间暂居不大，且连续
  堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间

  - 简单数据类型直接使用栈内存
  - 复杂数据类型，二传手，引用地址在栈中，对象实际数据在堆中
    回收的时候 栈回收（指针偏移） 堆内存中的对象没有变量引用，慢慢回收

## 从内存机制理解闭包
- 执行流程
  - foo 函数 先编译 创建一个空执行上下文（全局执行上下文）
  - 执行foo 之前，有一个编译过程 ，setName,getName 会进行快速的词法扫描（var）
  闭包关注的是内部函数，myName test1 是由内部函数引用的自由变量，js会判断有闭包，会将自由变量存储在闭包中
  所以会在堆空间中创建一个closure(foo)

  - getName,setName 执行可以访问到closure(foo) 中的自由变量

  闭包核心 第一步 需要扫描内部函数 堆内存中
          第二步 自把内部函数引用的外部变量保存到堆中